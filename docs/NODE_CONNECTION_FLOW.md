# Node Connection Flow Documentation

This document explains how nodes connect to each other and communicate in the call center voice system.

## Overview

The system uses a hierarchical node-based architecture where:
- **Master Agent (RouterNode)** - The only agent that speaks to callers
- **Sub-Agent (DepartmentNode)** - Backend logic advisors that process requests
- **Tool Agent (SubAgentNode)** - Direct execution units that connect to integration nodes
- **Integration Node** - Connects to external data sources (Mock, REST, GraphQL)

## Node Types

### 1. RouterNode (Master Agent)
- **Type**: `NodeType.ROUTER`
- **Purpose**: The primary interface that speaks to callers
- **Connections**: Connects to DepartmentNodes via intent-based edges
- **Data Structure**: `RouterNodeData`

### 2. DepartmentNode (Sub-Agent)
- **Type**: `NodeType.DEPARTMENT`
- **Purpose**: Backend logic advisor that processes complex requests
- **Connections**: 
  - Receives connections from RouterNode
  - Connects to SubAgentNodes (Tool Agents) via tool-based edges
- **Data Structure**: `DepartmentNodeData`

### 3. SubAgentNode (Tool Agent)
- **Type**: `NodeType.SUB_AGENT`
- **Purpose**: Direct execution unit for specific tool functions
- **Connections**:
  - Receives connections from DepartmentNode
  - Connects to IntegrationNode for data access
- **Data Structure**: `SubAgentNodeData`

### 4. IntegrationNode
- **Type**: `NodeType.INTEGRATION`
- **Purpose**: Connects to external data sources
- **Types**: `mock`, `rest`, `graphql`
- **Connections**: Receives connections from SubAgentNode
- **Data Structure**: `IntegrationNodeData`

## Connection Flow

### Step 1: Master Agent → Sub-Agent

**How it works:**
1. Master Agent receives caller input
2. Master Agent calls `generateToolsForAgent(agentNodeId)` to discover available tools
3. Tools are generated by finding all outgoing edges from the Master Agent node
4. For each edge to a DepartmentNode, a tool is created with name from `getToolName(node)`
5. Master Agent calls the tool (which triggers `runSubAgentLoop`)

**Code Location:**
- Tool generation: `components/TestPanel.tsx:502` - `generateToolsForAgent`
- Tool name generation: `components/TestPanel.tsx:435` - `getToolName`
- Sub-agent execution: `components/TestPanel.tsx:1061` - `runSubAgentLoop`

**Edge Structure:**
```typescript
{
  source: masterAgentId,
  target: departmentNodeId,
  sourceHandle: `intent-${intentName}`,  // e.g., "intent-Reservations"
  animated: true
}
```

### Step 2: Sub-Agent → Tool Agent

**How it works:**
1. Sub-Agent receives query from Master Agent
2. Sub-Agent calls `generateToolsForAgent(departmentNodeId)` to discover available tools
3. Tools are generated by finding all outgoing edges from the DepartmentNode
4. For each edge to a SubAgentNode, a tool is created
5. Sub-Agent calls the tool (which triggers `executeToolLogic`)

**Code Location:**
- Tool generation: `components/TestPanel.tsx:502` - `generateToolsForAgent`
- Tool execution: `components/TestPanel.tsx:583` - `executeToolLogic`

**Edge Structure:**
```typescript
{
  source: departmentNodeId,
  target: toolAgentId,
  sourceHandle: `tool-${toolName}`,  // e.g., "tool-ConfirmReservation"
  animated: true
}
```

### Step 3: Tool Agent → Integration Node

**How it works:**
1. Tool Agent receives execution request with parameters
2. Tool Agent calls `executeToolLogic(toolNodeId, args)`
3. `executeToolLogic` finds connected IntegrationNode by:
   - Finding edges where `source === toolNodeId`
   - Checking if target node type is `NodeType.INTEGRATION`
4. Based on integration type, calls appropriate execution function:
   - `mock` → `executeMockIntegration`
   - `rest` → `executeRestIntegration`
   - `graphql` → `executeGraphQLIntegration`

**Code Location:**
- Integration discovery: `components/TestPanel.tsx:606-612`
- Mock execution: `components/TestPanel.tsx:729` - `executeMockIntegration`
- REST execution: `components/TestPanel.tsx:778` - `executeRestIntegration`
- GraphQL execution: `components/TestPanel.tsx:859` - `executeGraphQLIntegration`

**Edge Structure:**
```typescript
{
  source: toolAgentId,
  target: integrationNodeId,
  animated: true
}
```

## Tool Name Generation

Tool names are generated using the `getToolName` function to ensure uniqueness and prevent conflicts.

**For SubAgentNode:**
```typescript
const base = data.functionName || data.agentName || `consult_${data.specialty?.toLowerCase() || 'tool'}`;
return `${base.replace(/[^a-zA-Z0-9_]/g, '_')}_${cleanId}`;
```

**For DepartmentNode:**
```typescript
const base = data.agentName || 'department';
return `consult_${base.replace(/[^a-zA-Z0-9_]/g, '_')}_${cleanId}`;
```

The `cleanId` is the node ID with special characters removed to ensure valid function names.

## Data Flow

### Request Flow (Top to Bottom)

1. **Caller Input** → Master Agent
2. **Master Agent** → Calls tool → Sub-Agent
3. **Sub-Agent** → Calls tool → Tool Agent
4. **Tool Agent** → Executes → Integration Node
5. **Integration Node** → Returns data

### Response Flow (Bottom to Top)

1. **Integration Node** → Returns JSON data
2. **Tool Agent** → Normalizes response → Returns to Sub-Agent
3. **Sub-Agent** → Processes data → Summarizes → Returns to Master Agent
4. **Master Agent** → Formats response → Speaks to caller

## Response Structure

### Integration Node Response

**Mock Integration:**
```typescript
{
  status: "success",
  source: "mock_db",
  data: { ... },  // The actual mock data
  metadata: {
    structure: "object with fields: ...",
    summary: "...",
    keys: [...],
    args_received: { ... }
  }
}
```

### Tool Agent Response (After Normalization)

```typescript
{
  success: true,
  data: { ... },  // Flattened data at top level
  summary: "...",  // Human-readable summary
  structure: "...",  // Structure description
  metadata: {
    source: "tool",
    duration: 123
  }
}
```

### Sub-Agent Response Format

When tool results are passed to Sub-Agent:
```typescript
{
  result: {
    success: true,
    data: { ... },  // Actual data
    summary: "...",
    structure: "...",
    error: "...",  // Only if error
    errorCode: "..."  // Only if error
  },
  _instruction: "The 'data' field contains the actual data..."
}
```

## Visual Feedback

### Node Highlighting

Nodes are highlighted during execution to show the flow:
- **Master Agent** → Highlighted when processing
- **Sub-Agent** → Highlighted when called
- **Tool Agent** → Highlighted when executing
- **Integration Node** → Highlighted when accessing data

**Implementation:**
- `onSetActiveNodes([nodeId1, nodeId2, ...])` - Highlights multiple nodes
- Highlighting persists for 2-3 seconds for visibility

### Edge Animation

Edges are animated to show data flow:
- `animateEdges([{ source: nodeId1, target: nodeId2 }])` - Animates edge

## System Prompt Instructions

### Sub-Agent System Prompt

The Sub-Agent receives explicit instructions on how to read tool responses:

```
HOW TO READ TOOL RESPONSES:
When you call a tool, you will receive a response with this structure:
{
  "result": {
    "success": true/false,
    "data": { ... },  // THIS IS THE ACTUAL DATA - READ ALL FIELDS HERE
    "summary": "...",  // Quick overview
    "structure": "...",  // Description of structure
    "error": "...",  // Only if error
    "errorCode": "..."  // Only if error
  }
}

CRITICAL INSTRUCTIONS:
1. The 'data' field contains the actual information - ALWAYS read this field
2. If 'data' is an object, read ALL fields in it
3. Use the 'summary' field to quickly understand what data is available
4. The 'structure' field tells you what type of data it is
```

## Error Handling

### At Each Level

1. **Integration Node**: Returns error with `errorCode`
2. **Tool Agent**: Catches errors, normalizes, returns error structure
3. **Sub-Agent**: Handles tool errors, can request clarification
4. **Master Agent**: Handles sub-agent errors, provides fallback response

### Error Structure

```typescript
{
  error: "Error message",
  errorCode: "ERROR_CODE",
  details: { ... }  // Optional additional details
}
```

## Logging

Comprehensive logging is added at each step:

1. **Mock Data Access**: Logs when mock data is accessed, what structure is returned
2. **Tool Execution**: Logs raw result, normalized result, data structure
3. **Tool Result Formatting**: Logs formatted result before sending to sub-agent
4. **Sub-Agent Response**: Logs final answer extraction and normalization

All logs use `addLog('debug', ...)` for detailed debugging information.

## Usage Tracking

Node usage is tracked via `onUpdateNodeUsage(nodeId)`:
- Called when Integration Node is accessed
- Tracks how many times each node is used
- Displayed as numbers on nodes

## Best Practices

1. **Always connect Integration Nodes to Tool Agents** - Tool Agents need data sources
2. **Use descriptive tool names** - Helps AI understand what tools do
3. **Provide clear system prompts** - Sub-Agents need explicit instructions
4. **Include data structure hints** - Helps AI parse responses correctly
5. **Add comprehensive logging** - Essential for debugging connection issues

## Common Issues and Solutions

### Issue: Sub-Agent can't access mock data

**Solution:**
- Ensure Integration Node is connected to Tool Agent via edge
- Check that mock data JSON is valid
- Verify tool result is properly formatted with `data` field at top level
- Check system prompt includes instructions on reading tool responses

### Issue: Nodes not highlighting

**Solution:**
- Ensure `onSetActiveNodes` is called with correct node IDs
- Check that highlighting duration is long enough (2-3 seconds)
- Verify nodes are in the nodes array

### Issue: Tool not found

**Solution:**
- Verify edge exists between nodes
- Check `getToolName` generates correct tool name
- Ensure tool is in `generateToolsForAgent` output
- Check tool name matching in sub-agent loop

## Future Enhancements

1. **Connection validation** - Validate connections before execution
2. **Connection testing** - Test connections independently
3. **Visual connection editor** - Better UI for managing connections
4. **Connection templates** - Pre-built connection patterns
5. **Connection analytics** - Track connection performance

